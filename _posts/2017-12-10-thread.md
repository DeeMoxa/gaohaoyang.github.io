---
layout: post
title: "多线程"
excerpt: ""
tag: thread
---
_涉及到多线程的理论始终不够清晰条理，索性总结一篇以自勉_  
[分享一个有趣的图文博客](https://www.cnblogs.com/xinyuyuanm/archive/2013/05/19/3087596.html)  
## 定义

**Wiki:** In computer science, a thread of execution is the smallest sequence of programmed instructions that can be managed independently by a scheduler, which is typically a part of the operating system. The implementation of threads and processes differs between operating systems, but in most cases a thread is a component of a process. Multiple threads can exist within one process, executing concurrently and sharing resources such as memory, while different processes do not share these resources. In particular, the threads of a process share its executable code and the values of its variables at any given time.
{: .notice--info}

简述wiki的描述：  
线程是进程的组件，同进程内线程共享资源。
随之产生的概念：  
并发：同一时间只有一个cpu实例访问  
并行：同一时间可以有个cpu实例访问
引用示例简图  
<img src="{{ site.url }}{{ site.baseurl }}/images/thread/concurrent-parallel.png" alt="concurent-parallel">

### 线程安全
涉及到事务的概念 [transaction]({{ site.url }}{{ site.baseurl }}/posts/transaction)  
### 线程同步
单一时间内并发访问。e.g. synchronized关键字

## 线程各状态转换
引用api说明  
<a href ="{{ site.url }}{{ site.baseurl }}/images/thread/enum-threadstate.jpg">
<img src="{{ site.url }}{{ site.baseurl }}/images/thread/enum-threadstate.jpg"></a>  

<img src="{{ site.url }}{{ site.baseurl }}/images/thread/thread_states.png">  

<table>
<tr  style="text-align:center;">
    <td style="width:10%">方法名</td>
    <td style="width:60%">简介摘要</td>
    <td style="width:30%">总结</td>
</tr>
<tr>
    <td>start()</td>
    <td>
    </td>
    <td>线程起点  //调用run();</td>
</tr>
<tr>
    <td>join()</td>
    <td><a href ="{{ site.url }}{{ site.baseurl }}/images/thread/thread-join.jpg"><img src="{{ site.url }}{{ site.baseurl}}/images/thread/thread-join.jpg" ></a></td>
    <td>等待直到线程死亡  //使用wait();实现</td>
</tr>
<tr>
    <td>sleep()</td>
    <td><a href ="{{ site.url }}{{ site.baseurl }}/images/thread/thread-sleep.jpg"><img src="{{ site.url }}{{ site.baseurl}}/images/thread/thread-sleep.jpg" ></a></td>
    <td>睡眠暂停线程，依赖系统调度</td>
</tr>
<tr>
    <td>wait()</td>
    <td></td>
    <td>继承自object，等待直到其他线程invoke notify(); or notifyAll();</td>
</tr>
<tr>
    <td>notify()</td>
    <td><a href ="{{ site.url }}{{ site.baseurl }}/images/thread/object-notify.jpg"><img src="{{ site.url }}{{ site.baseurl}}/images/thread/object-notify.jpg" ></a></td>
    <td>继承自object，唤醒一个等待该object的线程，与等待的其他线程共同竞争</td>
</tr>
<tr>
    <td>notifyAll()</td>
    <td><a href ="{{ site.url }}{{ site.baseurl }}/images/thread/object-notifyAll.jpg"><img src="{{ site.url }}{{ site.baseurl}}/images/thread/object-notifyAll.jpg" ></a></td>
    <td>唤醒所有等待 ...</td>
</tr>
<tr>
    <td>yield()</td>
    <td><a href ="{{ site.url }}{{ site.baseurl }}/images/thread/thread-yield.jpg"><img src="{{ site.url }}{{ site.baseurl}}/images/thread/thread-yield.jpg" ></a></td>
    <td>注释说的比较难理解。简单解释为，让行。执行该方法的线程并没有释放锁，只是让scheduler把它的优先级放后</td>
</tr>
</table>
### Monitor
看完上表，在官方注释中有一个重要的概念，monitor（监视器、监视锁）。
引用[stackoverflow的回答](https://stackoverflow.com/questions/3362303/whats-a-monitor-in-java)：
Java中Object本身即Monitor对象，它会关联每个对象。
![]({{ site.url }}{{ site.baseurl }}/images/thread/monitor.jpg)  
了解了monitor的基本定义，上面的表格中还体现出一个问题。wait();notify();notifyAll();三个方法并不属于thread类而是Object对象的方法。这里也可以体现出Object即Monitor的理论。
#### synchronized
<a href="{{ site.url }}{{ site.baseurl }}/images/thread/thread/synchronized.jpg">![]({{ site.url }}{{ site.baseurl }}/images/thread/synchronized.jpg)</a>
摘自[oralce官方文档](https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html#jls-17.1)，提炼几个关键点：  
1. 最基本的同步就是使用monitor实现（也验证了上面每个对象都关联Monitor的说法）
2. synchronized statement 会计算对象引用，直到运行完成。
3. synchronized method 当方法被调用就锁定，如果执行方法的是instance则锁定关联instance的monitor，如果方法是static的则锁定关联的class object的monitor，如果正在执行的方法完成了，则自动解锁。

[最后转一篇习题](http://www.importnew.com/12773.html)
